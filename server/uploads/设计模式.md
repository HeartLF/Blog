# 设计模式

## 单例模式

- 定义：保证一个类有且仅有一个实例，并提供一个访问它的全局访问点

- 优点：

  - 在内存中只有一个实例，减少内存开销，尤其的是频繁的创建和销毁实例
  - 避免对资源的多重利用

- 缺点：

  - 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外部怎么来实例化，

- 实现代码：

  ```js
  const singleton = function(name) {
      this.name = name
      this.instance = null
  }
  singleton.prototype.getName = function() {
      console.log(this.name)
  }
  singleton.getInstance = function(name) {
      if (!this.instance) { // 关键语句
          this.instance = new singleton(name)
      }
      return this.instance
  }
  // test
  const a = singleton.getInstance('a') // 通过 getInstance 来获取实例
  const b = singleton.getInstance('b')
  console.log(a === b)
  ```


## 观察者模式

- 定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
- 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度协助
- 何时使用：一个对象的状态变化，所有依赖的对象都将得到通知，进行广播通知。
- 如何解决：使用面向对象技术，可以将这种依赖关系弱化
- 优点：
  - 观察者和被观察者是抽象耦合的
  - 建立一套触发机制
- 缺点：
  - 如果一个观察者对象有很多直接和间接观察者的话，将所有的观察者都通知到会花费很多时间
  - 如果再观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环引用，可能导致系统崩溃
  - 观察者模式没有相应的机制让观察者所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了改变

## 工厂模式

### 简单工厂模式

- 定义：简单工厂模式提供了工厂类用于创建对象，将对象的创建和对象的使用分开
- 优点：
  - 实现了创建对象与使用对象的分离
  - 无需知道具体产品的类名
  - 通过引入配置文件，无需修改代码即可更换和增加新的具体产品类，提高系统的灵活性
- 缺点：
  - 职责过重，一旦程序出错，整个系统都不能运行
  - 引入新的工厂，会导致增加了系统的复杂性和理解程度
  - 违反了开闭原则，一旦新增产品必须修改原有代码
  - 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构
- 适用环境：
  - 创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂
  - 客户端只需要传入工厂方法参数，无需知道对象如何创建

### 工厂方法模式

- 定义：工厂方法是简单工厂模式的延申，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足
- 优点：
  - 用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类名
  - 所有的具体工厂类都具有同意抽象父类，被称为多态工厂模式
  - 符合开闭原则，新增产品只需要添加工厂类和具体产品，无需修改代码，扩展性好
- 缺点：
  - 添加一个新的产品，系统中类的个数增加，导致增加了系统的复杂性，有更多的类需要编译和运行，会增加系统性能的开销
  - 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度
- 适用环境
  - 客户端不知道他所需要的对象的类
  - 抽象工厂类通过其子类来指定创建那个对象。利用面向对象的多态性，在程序运行时子类覆盖父类对象，从而使得系统更容易扩展

### 抽象工厂模式

- 定义：抽象工厂方法时工厂方法模式的延申，它提供了功能更为强大的工厂类并且具备较好的可扩展性
- 优点：
  - 抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建
  - 当一个产品族中的对象被设计成一起工作时，它能够保证客户端始终只使用同一产品族中的对象
  - 增加新的产品族很方便，无需修改已有系统代码，符合开闭原则
- 缺点：
  - 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了开闭原则
- 使用环境：
  - 用户无需关心对象的创建过程，将对象的创建和使用解耦